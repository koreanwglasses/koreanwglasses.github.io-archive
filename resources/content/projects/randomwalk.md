---
replicate: true
---

_Before 2016_

While playing around on WolframAlpha, I discovered that it could generate non-self-intersecting random walks on a 2D lattice. However, it would always stop when it came to a dead end. Unsatisfied with this, I decided to write my own algorithm do generate arbitrarily long self-avoiding random walks using algorithms such as backtracking. However, simple backtracking would take forever to realize that the walk had already closed itself off, so I continued to tinker until I found what is described below: a loop checking/self-avoiding random walk generator that runs in polynomial time (with respect to path length).

 _Youtube Video_

 ![2000 Step Self-Avoiding Random Walk](/resources/assets/randomwalk/randomwalk-2000-lg.png) 
 
 _Written in Python_ 
 
 Generates a random walk of arbitrary length in polynomial time by using a combination of backtracking and turning numbers to make sure the path head (red dot) does not trap itself 
 
 **How it works:** 
 
 *Backtracking* 
 
 The backtracking algorithm works without recursion by traversing a tree. Each node is a "step," and each of its children are "steps" that potentially lead to a solution.
 
 This is implemented dynamically, with a stack that only stores one set of children at a time. If a node produces no children, that node is popped from the stack, and the children of the next node are pushed onto the stack. This ensures that the space complexity does not grow exponentially. The specific implementation can be found in the source files.
 
 *Loop Checking* 
 
 The random walk is generated by tracing the path of a "head," which can move into any neighboring point on an integer lattice that has not already been visited. If, at any point, the head gets "stuck" (i.e there are no neighboring spots which the head can move to), the head backtracks to a previous point where the head was not stuck, and it continues from there. 
 
 This works well, until the head closes itself off in a loop. In a loop, even though the path will not lead to a solution (i.e. an arbitrarily long random walk), because there are unvisited neighbors around the head, the algorithm does not backtrack. Instead, it will attempt every possible permutation of points inside the area enclosed, which takes a lot of time to escape (on the order of O(n!), where n is the area enclosed) ! 
 
 Download Source Files:

*   Backtracking Framework - [backtracking.py](/resources/assets/randomwalk/backtracking.py)
*   Randomwalk Py - [randomwalk2.py](/resources/assets/randomwalk/randomwalk2.py)

Running the program: *This program requires that matplotlib be installed. Can be run on both Python 2 and 3.*

*   Place 'backtracking.py' in the same folder as 'randomwalk2.py'.
*   Run 'randomwalk2.py'.
*   Enter number of steps then hit enter.
*   The result should render itself in the figure when it is complete.

*Set 'plot = true' in line 7 of 'randomwalk2.py' for a live view of the random walk!*